import{_ as a,D as n,o,c as l,G as p,V as t}from"./chunks/framework.ab6d8354.js";const g=JSON.parse('{"title":"浅谈“this”（上）","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/front-base/2023-05-16-talk-this1.md","filePath":"blogs/front-base/2023-05-16-talk-this1.md","lastUpdated":1684998501000}'),e={name:"blogs/front-base/2023-05-16-talk-this1.md"},c=t(`<h1 id="浅谈-this-上" tabindex="-1">浅谈“this”（上） <a class="header-anchor" href="#浅谈-this-上" aria-label="Permalink to &quot;浅谈“this”（上）&quot;">​</a></h1><p>在JavaScript中，我们对<strong>this</strong>肯定并不陌生，在函数中，我们经常用<strong>this.foo</strong>来访问对象属性，但是在一些复杂的函数逻辑中，我们需要搞清楚的一个问题是<strong>this</strong>到底指向谁？在近期的学习回顾中，我且谈一谈自己对<strong>this</strong>的理解。</p><h2 id="调用位置" tabindex="-1">调用位置 <a class="header-anchor" href="#调用位置" aria-label="Permalink to &quot;调用位置&quot;">​</a></h2><blockquote><p>在理解<strong>this</strong>的绑定过程之前，首先我们要理解的一个概念是<strong>调用位置</strong>，<strong>调用位置</strong>就是函数在代码中被调用的位置（这里特别要强调的一点是：<strong>调用位置</strong>并不是<strong>声明位置</strong>），只有仔细分析<strong>调用位置</strong>才能搞清楚<strong>this</strong>到底指向的（或者说引用的）是什么？</p></blockquote><p>通常来说，要寻找调用位置就是寻找“函数被调用的位置”，这听起来很简单，只需要看函数在哪被调用，但是做起来却并没有那么容易，因为有些编程模式可能会隐藏真正的调用位置，所以最重要的是分析<strong>调用栈</strong>。</p><p>那么什么是调用栈？调用栈就是指<strong>为了到达当前执行位置所调用的所有函数</strong>，这听起来可能会有些绕口，用通俗的话来讲，函数要被调用首先得进栈，若一个调用栈中包含A,B,C三个函数，且他们的调用顺序为A-&gt;B-&gt;C，而我们关心的调用位置则是当前正在执行的函数的上一个调用，讲到这里可能就会很明白了，C的调用位置是B，而B的调用位置就是A，那A的调用位置呢？如果A处于调用栈的顶端，则A的调用位置为全局作用域。</p><h2 id="默认绑定" tabindex="-1">默认绑定 <a class="header-anchor" href="#默认绑定" aria-label="Permalink to &quot;默认绑定&quot;">​</a></h2><blockquote><p>在理解了<strong>调用位置</strong>之后，我们就可以来谈谈<strong>this</strong>的绑定规则了。</p></blockquote><p>思考以下代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">baz</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">baz</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//2</span></span></code></pre></div><p>这里我们通过 var a =2 声明了一个全局变量a,但我们调用 baz 时，this.a 被解析成为了全局变量 a,那就是说我们这里的 this 指向的是全局作用域，为什么？ 这就是我们要谈的第一点规则，<strong>默认绑定</strong>。在这里的调用栈即为 baz ，所以 this 被默认绑定到了全局对象上，因此 this 指向的就是全局对象。</p><blockquote><p>但是这里有一个非常重要的细节，只有函数运行在非<strong>严格模式</strong>的情况下， this 才能默认绑定到全局对象，在<strong>严格模式</strong>下 this 是不允许绑定到全局对象上的，如果你要问我什么是严格模式,上百度Google一下。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">baz</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">baz</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//TypeError: this is undefined</span></span></code></pre></div></blockquote><p>在node环境中，在开启strict模式的ES6语法下，上述代码也会是undefined，因为ES6禁止将 this 指向全局对象。</p><h2 id="隐式绑定" tabindex="-1">隐式绑定 <a class="header-anchor" href="#隐式绑定" aria-label="Permalink to &quot;隐式绑定&quot;">​</a></h2><p>这是我个人认为使用的最多的一条规则，即判断调用位置是否有上下文。</p><p>思考以下代码</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">foo </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> foo</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//2</span></span></code></pre></div><p>首先要声明的一点是，不管 foo 是如何定义在对象obj中的，这个函数严格来说都不属于obj对象。然而，调用位置会使用obj上下文来引用函数，因此为了方便理解，可以说成函数被调用时obj对象“包含”或者“拥有”它。但如果我直接调用 foo() 而不是使用 obj.foo(),结果会怎么样呢？那就和我们上文所说的<strong>默认绑定</strong>一样，在非严格模式下，this 会绑定到全局对象，而全局对象上并没有属性 a ,则结果为 undefined 。</p><p>一种更微妙的情况发生在传入回调函数时：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">doFoo</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fn</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">foo</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;"> i am global</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">doFoo</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>思考一下，这里打印的a将会是什么？ 是 obj对象属性a = 2 还是全局对象属性 a = “ i am global”？ 我可以很负责任的告诉你，打印出来的将会是” i am global”。</p><p>为什么？在调用foo的时候不是有obj上下文吗？为什么 this 不会指向obj对象？其实仔细分析一下函数的调用位置就会知道，函数是在doFoo里的 fn() 处被调用的，obj.foo只是一个参数传递，相当于 var bar = obj.foo； doFoo(bar);这里的bar只是函数的一个别名，实际上他引用的还是foo本身，和直接调用foo()是一个原理，因此 this 默认绑定在了全局对象上，称之为隐式丢失。</p><h2 id="显式绑定" tabindex="-1">显式绑定 <a class="header-anchor" href="#显式绑定" aria-label="Permalink to &quot;显式绑定&quot;">​</a></h2><blockquote><p>分析完上面两种绑定方式，你可能会想：能不能不要创建函数对象，把 this 绑定到我想要绑定的函数或者对象上去呢？ 答案是可以的，JavaScript提供了call()和apply()方法帮助你实现更自由的 this 绑定。</p></blockquote><p>这两个方法是如何工作的呢？ 他们的第一个参数是一个对象，他们会把这个对象绑定到 this ，接着在调用函数时指定这个 this 。文字说明可能不太好懂，来看一下代码。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(obj)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//2</span></span></code></pre></div><p>通过foo.call()可以在调用foo时强制把它的this绑定到obj上。但是如果传入的值是一个字符串或者布尔类型的值，那么它将会被转换成他的对象形式，也就是 new String()、new Boolean()。</p><p>典型的应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">funtion </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">(something)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">something</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">something</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> bar </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">foo</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">apply</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">arguments</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;">// 2 3</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(b)</span><span style="color:#89DDFF;">;</span><span style="color:#676E95;font-style:italic;">// 5</span></span></code></pre></div><p>这是显式绑定的一种变种方式称之为硬绑定，他可以解决上文所提到的隐式丢失问题，防止函数调用 this 被绑定到全局对象上，但是这种绑定方式未免显得太过僵硬，大大降低了函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this 。那如果我需要动态修改 this 的指向呢？ 也不是没有方法，思考一下，写了一上午有点饿，下篇博客再讲。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>判断 this 的指向，最重要的是判断函数的调用位置，可以说，函数的调用位置决定了 this 指向的对象。</p>`,32);function r(y,F,D,i,A,C){const s=n("git-talk");return o(),l("div",null,[c,p(s)])}const d=a(e,[["render",r]]);export{g as __pageData,d as default};
